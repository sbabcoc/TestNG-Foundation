# Cohesive test execution management with ExecutionFlowController

The **`ITestResult`** object includes an attribute storage facility that enables you to attach a collection of unique values to each test method. The test result object is available essentially everywhere via the **`Reporter.getCurrentTestResult()`** method. However, every method (`before` configuration, test method, and `after` configuration) gets its own isolated test result object. There's no built-in facility that enables you to attach values to a test through the entirety of its execution. Attributes added in a `before` configuration method won't be propagated to the test method that it's setting up for. Attributes added in a test method won't be propagated to the `after` configuration method that cleans up after the test method ends. If you need this sort of continuity, you're forced to implement this propagation yourself.

A concrete example of a scenario in which a value must be propagated from **`@BeforeMethod`** configuration to **`@Test`** method to **`@AfterMethod`** configuration is a [Selenium WebDriver](https://github.com/sbabcoc/Selenium-Foundation) test, in which every phase of the test must use the same driver object to interact with the browser session. Selenium Foundation relies on the attribute propagation provided by **`ExecutionFlowController`** to ensure that a single driver object is used for setup, test execution, and cleanup. It's also used to hand off the page object representing the page that the browser is currently showing from the setup method to the test method.

You could achieve similar results via **`ThreadLocal`** storage, but this requires you to figure out how to prevent values from improperly propagating from one test to the next. (When running in non-parallel mode, all of the tests in your suite run sequentially on a single thread.)